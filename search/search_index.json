{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Welcome to VoltScript Logging documentation","text":"<p>VoltScript Logging is a script for managing logs and error objects. To allow it to be integrated as much as possible, there are no dependencies. VoltScript Testing is used for running unit tests.</p>"},{"location":"index.html#whats-new","title":"What's new","text":"<p>For the latest release information about VoltScript Logging, see What's new.</p>"},{"location":"index.html#using-via-dependency-management","title":"Using via dependency management","text":"<p>For using with dependency management, see Use dependency management.</p>"},{"location":"index.html#how-the-documentation-is-organized","title":"How the documentation is organized","text":"<p>The documentation is based on the Di\u00e1taxis framework, which organizes documentation into the following modes to address users' documentation needs at different times and in different circumstances. Below shows an overview that guides you on where to look for needed information:</p> <p>Tutorials - Hands-on introduction on how to use VoltScript Logging</p> <p>How-to guides - Practical step-by-step guides for performing tasks and operation</p> <p>Topic guides - High-level discussion and explanation of key topics and concepts in VoltScript Logging</p> <p>References - Contain API documentation and test reports</p>"},{"location":"howto/index.html","title":"How-to guides","text":"<p>How-to guides instruct users in completing key goals and tasks relative to VoltScript Logging.</p> <ul> <li>Integrate Logging</li> <li>Use LogWriters</li> <li>Extend BaseLogWriter</li> <li>Error tracking</li> <li>Use dependency management</li> </ul>"},{"location":"howto/archipelago.html","title":"Use dependency management","text":"<p>Info</p> <p>For generic how-to information about VoltScript Dependency Management, see VoltScript documentation.</p> <p>Dependency management is available in the documentation for each project, but also aggregated here:</p>"},{"location":"howto/archipelago.html#authentication","title":"Authentication","text":"<p>You'll need a Personal Access Token to use GitHub REST APIs. You'll then need to add the following to the JSON object in your atlas-settings.json in the <code>.vss</code> directory of your user home directory:</p> <pre><code>    \"hcl-github\": {\n        \"type\": \"github\",\n        \"token\": \"${env.TOKEN}\"\n    }\n</code></pre>"},{"location":"howto/archipelago.html#repository","title":"Repository","text":"<p>You'll need to add the following to your repositories object in the <code>atlas.json</code> of your project:</p> <pre><code>        {\n            \"id\": \"hcl-github\",\n            \"type\": \"github\",\n            \"url\": \"https://api.github.com/repos/HCL-TECH-SOFTWARE\"\n        }\n</code></pre>"},{"location":"howto/archipelago.html#dependency","title":"Dependency","text":"<p>You'll need to add the following relevant dependency to your dependencies object in the <code>atlas.json</code> of your project:</p> <pre><code>        {\n            \"library\": \"voltscript-logging\",\n            \"version\": \"1.0.0\",\n            \"module\": \"VoltScriptLogging.vss\",\n            \"repository\": \"hcl-github\"\n        }\n</code></pre>"},{"location":"howto/errortracking.html","title":"Error tracking","text":"<p>Note</p> <p>This how to does not cover best practices around error handling. That is independent of a specific error tracking or logging library.</p> <p>Error tracking is used for capturing VoltScript errors. These are errors triggered by VoltScript error codes (e.g. 13, Type mismatch) or custom errors thrown by <code>Error errCode, errMsg</code>. The ErrorType object will automatically parse the error code, message, line number and stack trace to store the relevant information.</p> <p>Warning</p> <p>Remember that the error line and stack trace are based on where the Try/Catch is. If the error occurs in a sub or function being called, but that does not have error handling, the line number and stack trace will be based on the calling code. To get more granular information of precisely where the error was triggered, you will need to add error handling to the sub or function being called.</p> <p>The error tracking uses two classes:</p> <ul> <li>ErrorSession, accessed via <code>getErrorSession()</code>, a container for an array of <code>ErrorType</code> objects.</li> <li>ErrorType, automatically created and added to the session by <code>getErrorSession().addError()</code> function.</li> </ul> <p>ErrorTypes do not have an error level, a level is only relevant when logging the entry. You may wish to do different things depending on whether a custom error code (typically between 1000 and 1999), but that should be handled with implementation code in your Try/Catch block.</p>"},{"location":"howto/errortracking.html#get-errorsession","title":"Get ErrorSession","text":"<p>Like the LogSession, the ErrorSession instance is a singleton, lazy-loaded on the first call to <code>getErrorSession()</code>. Always use this method to retrieve the current ErrorSession, trying to do <code>Dim errorSess as New ErrorSession()</code> will throw an error.</p> <p>Info</p> <p>VoltScript objects cannot persist between script runs. So when the <code>Sub Initialize</code> is first triggered, the ErrorSession instance will be <code>Nothing</code>. When the <code>Sub Initialize</code> ends, the ErrorSession instance will be deleted.</p>"},{"location":"howto/errortracking.html#add-errors-to-the-session","title":"Add errors to the session","text":"<p>The expected way to create an ErrorType object is via <code>Call getErrorSession().addError()</code>. That function returns the <code>ErrorType</code> object, if you wish to do any additional processing with it like checking the error code for expected or unexpected errors.</p> <pre><code>Sub performFatalLoop\n\n    Dim i as Integer\n    Dim errType as ErrorType\n\n    For i = 0 to 10\n        Try\n            ' Do stuff\n            Error 1001, \"Generic rror on loop \" &amp; i\n        Catch\n            Set errType = getErrorSession().addError()\n            If (errType.code &lt; 1001) Then Exit Sub\n        End Try\n    Next\n\nEnd Sub\n</code></pre>"},{"location":"howto/errortracking.html#logging-errors","title":"Logging errors","text":"<p>The <code>errorCount</code> can be used to check whether errors have been logged. This can avoid passing errors up the stack, as below:</p> <pre><code>Sub Initialize\n\n    Dim errType as ErrorType\n\n    ' Additional code required here to add a LogWriter, or nothing gets written out!\n\n    Call performFatalLoop()\n    If (getErrorSession().errorCount &gt; 0) Then\n        Do\n            Set errType = getErrorSession().getAndRemoveLastError()\n            Call globalLogSession.createLogEntry(LOG_FATAL, errType.getLogMessage(), errType.stackTrace, \"\")\n        Loop Until errType is Nothing\n        Exit Sub\n    End If\n\nEnd Sub\n</code></pre> <p><code>ErrorType.getLogMessage()</code> formats the error string, error code and line number in a human-readable string. Additional information of method and script are in the stack trace, so we pass that to the LogEntry as the extended information.</p>"},{"location":"howto/errortracking.html#clearing-the-error-session","title":"Clearing the error session","text":"<p><code>getAndRemoveLastError()</code> will eventually clear the ErrorSession, allowing additional processing and future checks on <code>.errorCount</code>. However, there may be a scenario where you are not interested in the actual errors, but just want to clear the ErrorSession to continue processing. <code>ErrorSession.reset()</code> will do this, clearing all ErrorType objects from the session and setting error count back to 0.</p> <p>See sample code</p>"},{"location":"howto/logging.html","title":"Integrate logging in code","text":""},{"location":"howto/logging.html#get-logsession","title":"Get LogSession","text":"<p>The LogSession instance is a singleton, the global variable <code>globalLogSession</code>, instantiated in the script's <code>Initialize</code>. Always use this method to retrieve the current LogSession, trying to do <code>Dim logSess as New LogSession()</code> will throw an error.</p> <p>Info</p> <p>VoltScript objects cannot persist between script runs. So when the <code>Sub Initialize</code> is first triggered, the LogSession instance will be new and empty. When the <code>Sub Initialize</code> ends, the LogSession instance will be deleted.</p>"},{"location":"howto/logging.html#create-log-entries","title":"Create log entries","text":"<p>Tip</p> <p>Recommended best practice is to always create log entries of all levels, not to change code when you want to log or use conditionals to check whether or not to create a log entry. Instead, use conditionals when adding the LogWriters to the LogSession or setting the LogWriter level. This ensures cleaner code and simplicity for the flexible requirement of changing logging levels.</p> <p>The following snippet shows an example of creating log entries:</p> <pre><code>Function doProcessing(passedVal as Integer) as Boolean\n\n    Call globalLogSession.createLogEntry(LOG_DEBUG, \"Entered doProcessing\", \"\", \"\")\n    Try\n        If (passedVal &gt; 4) Then\n            Error 4000, \"Invalid entry\"\n        End If\n        Call globalLogSession.createLogEntry(LOG_DEBUG, \"Ran doProcessing successfully\", \"\", \"\")\n    Catch\n        Call globalLogSession.createLogEntry(LOG_ERROR, \"Error encountered\", \"Value passed: \" &amp; passedVal, \"\")\n    Finally\n        Call globalLogSession.createLogEntry(LOG_DEBUG, \"Finished doProcessing\", \"\", \"\")\n    End Try\n\nEnd Function\n</code></pre> <p>The parameters are:</p> <ol> <li>Log level. Using the constants is recommended, and the code ensures a valid log level is passed.</li> <li>A log message, typically not verbose.</li> <li>Extended information in string format.</li> <li>The class name the current code is in.</li> </ol> <p>A unique identifier will be assigned to the LogEntry and a timestamp captured in UTC ISO 8601 format. The full stack trace will also be captured, as will the script name and method. Consequently, this information does not need to be included in the message or extended info.</p>"},{"location":"howto/logging.html#log-levels","title":"Log levels","text":"<p>The following log levels can be passed, from most severe to least:</p> <ol> <li>LOG_FATAL</li> <li>LOG_ERROR</li> <li>LOG_WARNING</li> <li>LOG_INFO</li> <li>LOG_DEBUG</li> <li>LOG_TRACE</li> </ol>"},{"location":"howto/logging.html#filter-log-entries","title":"Filter log entries","text":"<p>You can check for log entries at or above a specific level at any point. A use case for this might be to abort processing because there are problems that require fixing, as below:</p> <pre><code>    Dim i as Integer\n\n    Do\n        Call doProcessing(i++)\n        If (Not IsEmpty(globalLogSession.getLogEntriesByLevel(LOG_FATAL, LOG_FATAL)) Then\n            Print \"Exiting at \" &amp; --i ' (1)!\n            Exit Sub\n        End If\n    Loop\n</code></pre> <ol> <li>Line 4 has already incremented i from the value that caused the problem. So we decrement it before including in the Print statement.</li> </ol> <p>See sample code</p>"},{"location":"howto/logwriter.html","title":"Extend BaseLogWriter","text":"<p>The BaseLogWriter just prints to the console. This is unlikely to be sufficient for most scenarios. However, the class has been written to minimize and simplify code changes to output elsewhere. Specifically, you should not need to modify the <code>LogWriter.writeToLog()</code> function, which filters Log Entry objects and iterates them. You should only need to modify the following methods:</p> Method Reason to extend initializeLog() Action to be performed before writing each log. This is only triggered if there are any logs to be written. convertLogEntryToMessage() Use this if you do not intend to use a formatter. It should return a string to be written out. outputLogEntryMessage() This is where you put your custom logic to write to the relevant location. terminateLog() Action to be performed after writing all logs, such as closing a file or database connection."},{"location":"howto/logwriter.html#initializelog","title":"InitializeLog()","text":"<p>A typical use case for this function would be to create / open a log file or authenticate to a database. It is important to consider whether the code, when implemented, could be called concurrently. If so, your implementation should handle it. This function will only be called if the LogWriter has been added to the LogSession, and only if there are any logs to write after filtering has been performed.</p>"},{"location":"howto/logwriter.html#convertlogentrytomessage","title":"convertLogEntryToMessage()","text":"<p>The base method uses a string formatter replacing mustache variables with properties extracted from the LogSession and LogEntry. If that is sufficient, you do not need to override the method. If you want something more sophisticated, override this method to produce a string from the LogSession and LogEntry being iterated.</p> <p>Tip</p> <p>Remember: the formatter could be a JSON string, with variables inserted as appropriate. It could even be a string of YAML.</p>"},{"location":"howto/logwriter.html#outputlogentrymessage","title":"outputLogEntryMessage()","text":"<p>This is the method you will always want to override. This is where you do the specifics of writing the relevant content to the log. It will take in the string generated by <code>convertLogEntryToMessage()</code>, but may perform transformation, e.g. converting it to JSON.</p> <p>This method should minimize the amount of processing required. So if you need to write to a file, don't open it every time. Instead, open it in the <code>initializeLog()</code> and just write to it here.</p>"},{"location":"howto/logwriter.html#terminatelog","title":"terminateLog()","text":"<p>Use this method to clean up processing, e.g. closing a log file.</p> <p>Note</p> <p>If you want to collect everything into a single string and write that bulk string as a single operation, you can use <code>terminateLog()</code> to perform that. This may be more efficient. In this scenario, <code>outputLogEntryMessage()</code> would \"output\" it to a private variable that <code>terminateLog()</code> would use.</p>"},{"location":"howto/logwriter.html#custom-read-only-properties","title":"Custom read-only properties","text":"<p>VoltScript classes only allow one method to be overloaded - the constructor. Use this approach if you want to pass other values into the constructor, e.g. ensuring that they can only be set once. The syntax is a little complex:</p> <pre><code>Private myNewVariableHolder_ as Variant\n\nPublic Sub New(label As String, minLevel as Integer, maxLevel As Integer, formatter As String, myNewVariable as Variant), BaseLogWriter(label, minLevel, maxLevel, formatter)\n    myNewVariableHolder_ = myNewVariable\nEnd Sub\n</code></pre> <p>The method signature is followed by a comma, the base class name, and the variables to pass to its constructor. This will call the parent's constructor. It will then perform the additional code required, in this case passing <code>myNewVariable</code> argument to <code>myNewVariableHolder</code> variable.</p> <p>If you wish to have fewer arguments, you would do something like this:</p> <pre><code>Public Sub New(label as String, formatter as String), BaseLogWriter(label, LOG_TRACE, LOG_INFO, formatter)\n\nEnd Sub\n</code></pre> <p>This prevents the developer using this class to set a minimum or maximum level. Instead, it always sets the minimum level to LOG_TRACE and the maximum level as LOG_INFO.</p>"},{"location":"howto/uselogwriter.html","title":"Use LogWriters","text":"<p>LogWriters are designed to write logs to different locations. The LogWriter takes in four arguments:</p> <ul> <li>label: a unique label which will be the key in the Map of LogWriters.</li> <li>minLevel: a minimum level of a LogEntry to log.</li> <li>maxLevel: a maximum level of a LogEntry to log.</li> <li>formatter: a string formatter to produce the message to log.</li> </ul> <p>Logs will be outputted if they are at or above the minimum level and at or below the maximum level. For example, if the minimum level is LOG_TRACE and maximum level is LOG_INFO, logs with LOG_TRACE, LOG_DEBUG, and LOG_INFO will be written out. But logs with LOG_WARNING, LOG_ERROR, and LOG_FATAL will not be included.</p> <p>A special level is also available for <code>maxLevel</code> in LogWriters - NO_LOGGING. If the max level is NO_LOGGING, no logs will be processed and nothing written.</p>"},{"location":"howto/uselogwriter.html#setting-logging-level","title":"Setting logging level","text":"<p>Best practice is to define or retrieve the maximum logging level before you create the LogWriter. This could be done in a variety of ways:</p> <ul> <li>Hard-code in a constant at the top of your script. This makes it easier to find and change.</li> <li>Retrieve from an environment variable or other configuration source.</li> </ul>"},{"location":"howto/uselogwriter.html#dynamically-loading-loggers","title":"Dynamically loading loggers","text":"<p>A typical use case is wishing to define LogWriters in a configuration file. However, because this would require additional dependencies, for example JsonVSE to load from a JSON configuration file, this functionality is not included in the core code.</p>"},{"location":"howto/uselogwriter.html#changing-logging-level","title":"Changing logging level","text":"<p>The maximum level can only be set in the constructor. If you have to change it afterwards, you will need to create a new LogWriter. But be aware whether the LogWriter has already been added to the LogSession. If so, the correct method of processing would be:</p> <ul> <li>Remove the LogWriter from the LogSession (<code>getLogSession().logEntries.removeByKey(logWriter.label)</code>).</li> <li>Delete the LogWriter.</li> <li>Re-initialize the LogWriter.</li> </ul>"},{"location":"howto/uselogwriter.html#formatters","title":"Formatters","text":"<p>The formatter uses mustache syntax (<code>{{variable_name}}</code>) to replace content in the format. The following variables can be used:</p> Variable Explanation STACKTRACE The stack trace from the LogEntry LEVELNAME The name of the log level, e.g. FATAL ENTRYID The ID of the LogEntry LEVEL The numeric value of the log level, e.g. 32 MESSAGE The log message CLASSNAME The name of the class passed into the LogEntry LINENUM The line number passed into the LogEntry LIBRARYNAME The name of the library or module where the LogEntry was generated METHODNAME The name of the method or function where the LogEntry was generated TIMESTAMP The timestamp of the log entry EXTINFO Additional extended information passed into the log entry <p>Warning</p> <p>Variables are case-sensitive and must be entered in upper case in the formatter.</p>"},{"location":"howto/uselogwriter.html#sample-formatter","title":"Sample Formatter","text":"<p>This code will write out the level name (e.g. DEBUG), a colon, a space and the message:</p> <pre><code>Dim stringFormat as New BaseLogWriter(\"stringFormat\", LOG_DEBUG, LOG_FATAL, \"{{LEVELNAME}}: {{MESSAGE}}\")\n</code></pre> <p>This code will write out a pretty-printed JSON object containing the level name, message, extended info and stack trace. NOTE: the stack trace tracks out from the <code>Sub New</code> of the LogEntry class, through <code>Function createLogEntry</code> of the LogSession class, up to the calling code.</p> <pre><code>Dim jsonFormat  as New BaseLogWriter(\"jsonFormat\", LOG_DEBUG, LOG_FATAL, |{\n    \"level\": \"{{LEVELNAME}}\",\n    \"message\": \"{{MESSAGE}}\",\n    \"extendedInfo\": \"{{EXTENDEDINFO}}\",\n    \"stack\": \"{{STACKTRACE}}\"\n}|)\n</code></pre> <p>See sample code</p>"},{"location":"references/index.html","title":"References","text":"<p>References provide technical references and descriptions for using VoltScript Logging.</p>"},{"location":"references/index.html#whats-new","title":"What's new","text":"<p>Check the latest information about VoltScript Logging.</p>"},{"location":"references/index.html#repository-structure","title":"Repository structure","text":"<ul> <li>All the required code itself is in the VoltScript files in <code>src</code> directory.</li> <li>Tests are in test directory. Output are written to unit-test-reports directory.</li> </ul>"},{"location":"references/index.html#dependency-management","title":"Dependency management","text":"<p>For using VoltScript Logging via VoltScript Build Manager extension in Visual Studio Code, follow the instruction on the how-to guide.</p>"},{"location":"references/index.html#api-documentation","title":"API documentation","text":"<ul> <li>VoltScript Logging Class Documentation</li> </ul>"},{"location":"references/index.html#unit-test-output","title":"Unit test output","text":"<ul> <li>All tests</li> </ul>"},{"location":"references/index.html#faqs","title":"FAQs","text":"<p>List of frequently asked questions related to VoltScript Logging.  </p>"},{"location":"references/index.html#documentation-and-source-code","title":"Documentation and source code","text":"<ul> <li>HCL Volt MX Go Documentation</li> <li>VoltScript<ul> <li>Documentation</li> </ul> </li> <li>VoltScript Testing Framework<ul> <li>Documentation</li> <li>Source code</li> </ul> </li> <li>VoltScript Collections<ul> <li>Documentation</li> <li>Source code</li> </ul> </li> <li>VoltScript JSON Converter<ul> <li>Documentation</li> <li>Source code</li> </ul> </li> <li>VoltScript Console Colors<ul> <li>Source code</li> </ul> </li> <li>VoltScript Volt MX Middleware<ul> <li>Documentation</li> <li>Source code</li> </ul> </li> <li>VoltScript Interface Designer<ul> <li>Documentation</li> </ul> </li> </ul>"},{"location":"references/index.html#support","title":"Support","text":"<p>To share information, ask questions, and learn about VoltScript Logging, go to the Community.</p>"},{"location":"references/FAQs.html","title":"FAQs","text":""},{"location":"references/FAQs.html#why-cant-i-create-a-logsession-or-errorsession","title":"Why can't I create a LogSession or ErrorSession?","text":"<p>You should use the singletons returned by the global variable <code>globalLogSession</code> and global function <code>getErrorSession()</code>.</p>"},{"location":"references/FAQs.html#why-is-it-different","title":"Why is it different?","text":"<p>To make it logging as easy as possible, we use the <code>Delete</code> method of the <code>LogSession</code> object to write out the logs. However, if access is via a function, all properties of the LogSession get garbage collected by the start of Delete. Lists are still iterable, but all elements within the <code>logWriters</code> and <code>logEntries</code> list are garbage collected and <code>is Nothing</code> returns True.</p> <p>However, if LogSession is a global variable and is instantiated during the <code>Initialize</code> and is accessed as a global variable, they are still available.</p> <p>No functionality needs to run during the deletion of the <code>ErrorSession</code> object, it may not be used, and the <code>get...</code> paradigm is more familiar from other languages. So we retain the approach we intended originally for LogSession.</p>"},{"location":"references/FAQs.html#why-is-there-only-a-logwriter-for-printing-to-the-terminal","title":"Why is there only a LogWriter for printing to the terminal?","text":"<p>The framework provides tooling for managing errors and logs and is deliberately intended to minimize dependencies. The BaseLogWriter implements printing to the standard output, which can be done easily from the core language's <code>Print</code> function. Writing to a file or a database will require a VSE. To avoid polluting your project with unnecessary dependencies, we have decided not to include more sophisticated log writers. However, the tutorial explains how this can be done.</p>"},{"location":"references/FAQs.html#what-timezone-are-logs-logged-in","title":"What timezone are logs logged in?","text":"<p>We don't want to add dependencies, so only the core language is used. This means <code>Now()</code> core function, which uses the timezone of the operating system the VoltScript program running the code is deployed to.</p> <p>If you wish to force UTC, you can extend LogEntry class with a class that uses ZuluVSE. We'll not be adding dependencies to this library.</p>"},{"location":"references/whatsnew.html","title":"What's new","text":"<p>The section provides information on the latest features, improvements, and resolved issues related to VoltScript Logging.</p> v1.0.0 - What's new or changed"},{"location":"references/whatsnew.html#v100","title":"v1.0.0","text":"<ul> <li>First release version of VoltScript Logging.</li> </ul>"},{"location":"topicguides/index.html","title":"Topic guides","text":"<p>Topic guides discuss and explain topics and concepts about VoltScript Logging.</p> <ul> <li>Aims for the framework</li> <li>How it works</li> </ul> <p>For more information about writing VoltScript for Foundry, see the VoltScript documentation.</p>"},{"location":"topicguides/aims.html","title":"Aims for the framework","text":"<ul> <li>No dependencies.</li> <li>Standardization with frameworks in other languages with Java.</li> <li>Flexibility about where logs are written.</li> <li>Easy error capture.</li> <li>Extensibility.</li> <li>Ease of changing levels and locations for logs without amending code.</li> </ul> <p>No dependencies is a key requirement. We want to be able to integrate logging and error handling into all our other VoltScript Library Modules. That won't work if we depend on VoltScript Library Modules like VoltScript Collection or VoltScript Extensions like JsonVSE, ZuluVSE, or StreamVSE. So there are no dependencies and we'll not be adding any features that require them. Additional libraries can add dependencies, and remember that dependency management will download downstream dependencies for consumers.</p>"},{"location":"topicguides/aims.html#logsession-and-logentry","title":"LogSession and LogEntry","text":"<p>A LogEntry has six levels, equivalent to FATAL, ERROR, WARN, INFO, DEBUG and TRACE. These levels will be familiar to developers who have used logging frameworks in e.g. Java, Rust etc.</p> <p>The LogSession holds multiple log entries. The expectation is that the code does not handle whether or not logs are added to a session. Instead log entries should always be added to the LogSession. The specific LogWriters will handle whether or not logs for a specific level should be outputted by a specific LogWriter, and where / how they should be written.</p> <p>A sample scenario would be a LogSession with two LogWriters:</p> <ul> <li>LogWriter1 writing LOG_FATAL or LOG_ERROR logs to a file called \"errors.log\".</li> <li>LogWriter2 writing LOG_DEBUG and LOG_TRACE to a file called \"debug.log\" if an environment variable is set.</li> </ul>"},{"location":"topicguides/aims.html#errorsession-and-errortype","title":"ErrorSession and ErrorType","text":"<p>At this time no changes are being made to error handling in the core language. The same functions from LotusScript are available, with one addition:</p> <ul> <li>Error() gives the error message.</li> <li>Err() gives the error code.</li> <li>Erl() gives the line the Error was triggered on.</li> <li>getThreadInfo(12) is an addition to VoltScript and gives a safe-to-use stack trace.</li> </ul> <p>The aims of the framework are to make it as easy as possible to track errors. Thus <code>getErrorSession().addError()</code> creates an ErrorType object and adds it to the session. See the Error tracking how-to for more details.</p> <p>Again, error logging is separated from error tracking. Some errors may be handled differently from others - some may required immediate end of processing, others may be handled within the code. So ErrorTypes are not automatically added to the LogSession, you add them if required and with the relevant log level.</p>"},{"location":"topicguides/approach.html","title":"How it works","text":"<p>There is only one LogSession, accessed via the global variable <code>globalLogSession</code>. The code is deliberately designed to force this as a singleton, created during the <code>Initialize</code>.</p> <p>There is only one ErrorSession, accessed via the global function <code>getErrorSession()</code>. The code is deliberately designed to force this as a singleton, lazy loaded on first usage. You may wish to just pass error information directly to a LogEntry.</p>"},{"location":"topicguides/approach.html#structure","title":"Structure","text":"<p>The structure is as below:</p> <pre><code>erDiagram\n    LogSession ||--o{ LogEntry : contains\n    LogSession ||--o{ BaseLogWriter : contains\n    BaseLogWriter ||--o{ CustomLogWriters : extends\n    LogSession {\n        String sessionID\n        Integer entryCount\n        String sessionInfo\n    }\n    LogEntry {\n        String level\n        String entryID\n        Integer level\n        String libraryName\n        String className\n        String methodName\n        String timestamp\n        Integer linenum\n        String message\n        String extInfo\n        String[] stackTrace\n    }\n    BaseLogWriter {\n        String label\n        Integer level\n        String formatter\n    }\n    CustomLogWriters {\n        String label\n        Integer level\n        String formatter\n    }\n    ErrorSession ||--o{ ErrorType : contains\n    ErrorSession {\n        Integer errorCount\n    }\n    ErrorType {\n        Integer code\n        String message\n        Integer lineNum\n        String scriptName\n        String methodName\n        String stackTrace\n    }</code></pre> <p>The LogSession contains zero to many LogEntries in a List. Each LogEntry corresponds to a single log message to be outputted.</p> <p>The LogSession also contains zero to many LogWriters in a List. The LogWriter defines the minimum log level it should output, a format for what it should write, and a function to write each matching LogEntry.</p> <p>The ErrorSession contains zero to many ErrorTypes in an array.</p>"},{"location":"topicguides/approach.html#write-log-entries","title":"Write log entries","text":"<p>For instances of BaseLogWriter, the <code>Delete</code> sub of the LogSession handles writing the log entries with the <code>writeToLog()</code> function. For instances of any derived class, the <code>Delete</code> sub of the BaseLogWriter handles writing the log entries out.</p> <p>These functions handle identifying if it needs to log anything, initializing whatever location the logs will be written to, then writing each log, and doing any post-writing termination logic required, e.g. closing a file.</p> <p>Warning</p> <p>If code subsequently decides a LogWriter should not write out content, always remove it from the globalLogSession.</p> <p>Note</p> <p>Because there will be an increase in processing time for multiple LogWriters, it is best to minimize the number of LogWriters each piece of code needs to use or default to NO_LOGGING unless specifically switched on.</p> <p>For different logging purposes, you should create a class extending <code>BaseLogWriter</code> and override the functions required:</p> Method Reason to extend initializeLog() Action to be performed before writing each log. This is only triggered if there are any logs to be written. convertLogEntryToMessage() Use this if you do not intend to use a formatter. It should return a string to be written out. outputLogEntryMessage() This is where you put your custom logic to write to the relevant location. terminateLog() Action to be performed after writing all logs, such as closing a file or database connection. <p>The <code>writeLogEntry()</code> function handles how to write each log. It takes no arguments, so if there are objects required to write each log entry, e.g. a file to write to, these should be assigned to private variables in the class. It can call the <code>getFormattedString(LogEntry)</code> function to easily format a LogEntry to a string, replacing content in mustache template format with properties from the LogEntry. See the Format log output how-to for clarification.</p>"},{"location":"topicguides/approach.html#delete-processes-and-writing-logs","title":"Delete processes and writing logs","text":"<p>Classes variables are unloaded in reverse dependency-chain order. This means library modules are unloaded depending on their <code>Use</code> statement. First are \"leaf\" library modules that nothing else \"uses\", then \"branch\" library modules that only have <code>Use</code> statements pointing to already unloaded library modules. And finally \"trunk\" library modules that have no <code>Use</code> statements.</p> <p>Example:</p> <pre><code>flowchart TB\n    Start([Start])--&gt;A(\"src/main.vss&lt;br/&gt;\\nUse &amp;quot;libs/functions&amp;quot;\")\n    A--&gt;B(\"functions.vss&lt;br/&gt;&lt;br/&gt;Use &amp;quot;VoltScriptLogging&amp;quot;\")\n    B--&gt;C(\"VoltscriptLogging.vss\")\n    B--&gt;D(\"VoltScriptTesting.vss\")\n    C--&gt;Stop\n    D--&gt;Stop</code></pre> <p>Classes and variables in main.vss will be unloaded first. They classes and variables in functions.vss will be unloaded. Then VoltScriptLogging.vss and VoltScriptTesting.vss. Any instance of classes from main.vss or functions.vss that have been passed to classes in VoltScriptLogging will be <code>Nothing</code> by the time the Delete process of classes in VoltScriptLogging run during its unload.</p> <p>Of course if you extend <code>BaseLogWriter</code> class in functions.vss, <code>BaseLogWriter.Delete</code> method will get called from the extension when functions.vss is being unloaded and for <code>BaseLogWriter</code> itself when VoltScriptLogging.vss is unloaded.</p> <p>So the delete process needs to have two different flows:</p>"},{"location":"topicguides/approach.html#writing-logs-from-custom-logwriters","title":"Writing logs from custom LogWriters","text":"<p>As each instance of a custom LogWriter is unloaded, the <code>Delete</code> method will be called, and logs written out if appropriate.</p> <pre><code>flowchart TB\n    Start([Start])--&gt;A1(\"CustomLogWriter.delete()\")\n    A1-- \"No method so call parent method\" --&gt;A2(\"BaseLogWriter.delete()\")\n    A2--&gt;A3{\"In globalSession?\"}\n    A3-- Yes --&gt;A4\n    subgraph BaseLogWriter\n        A4--&gt;B(\"Call BaseLogWriter.writeToLog()\")\n        B--&gt;C(Filter Log Entries)\n        C--&gt;D{Any logs?}\n        D-- No --&gt;AA\n        D-- Yes --&gt;E(InitializeLog)\n    end\n    subgraph LogEntry\n        E--&gt;F[[Process Next LogEntry]]\n        F-- \"LogWriter.convertogEntryToMessage()\" --&gt;G{Use formatter?}\n        G-- Yes --&gt; I(\"LogWriter.format()\") --&gt; K{\"BaseLogWriter.outputLogEntryMessage()\"}\n        G-- No --&gt; J(Convert LogEntry to String) --&gt; K\n        K --&gt; L{More Logs to write?}\n        L-- No --&gt; M(\"BaseLogWriter.terminateLog()\")\n        L-- Yes --&gt; F\n        M --&gt; Stop\n    end\n    A4-- No --&gt; Stop</code></pre>"},{"location":"topicguides/approach.html#writing-logs-from-logsession","title":"Writing logs from LogSession","text":"<p>By the time the LogSession is unloaded, only instances of BaseLogWriter will exist. All custom LogWriters will have been set to <code>Nothing</code>.</p> <pre><code>flowchart TB\n    Start([Start])--&gt;A(\"LogSession.Delete()\")\n    subgraph LogSession\n        A--&gt;AA{Next BaseLogWriter?}\n        AA-- Yes --&gt;B(\"Call BaseLogWriter.writeToLog()\")\n    end\n    subgraph BaseLogWriter\n        B--&gt;C(Filter Log Entries)\n        C--&gt;D{Any logs?}\n        D-- No --&gt;AA\n        D-- Yes --&gt;E(InitializeLog)\n    end\n    subgraph LogEntry\n        E--&gt;F[[Process Next LogEntry]]\n        F-- \"LogWriter.convertogEntryToMessage()\" --&gt;G{Use formatter?}\n        G-- Yes --&gt; I(\"LogWriter.format()\") --&gt; K{\"BaseLogWriter.outputLogEntryMessage()\"}\n        G-- No --&gt; J(Convert LogEntry to String) --&gt; K\n        K --&gt; L{More Logs to write?}\n        L-- No --&gt; M(\"BaseLogWriter.terminateLog()\")\n        L-- Yes --&gt; F\n        M --&gt; Stop\n    end\n    AA -- No --&gt;Stop([Stop])</code></pre> <p>For more details on creating a custom LogWriter, see Extend BaseLogWriter.</p>"},{"location":"topicguides/approach.html#extend-baselogwriter","title":"Extend BaseLogWriter","text":"<p>The BaseLogWriter just prints to the output, which will only be relevant when running locally. Specific LogWriters should be created for outputting to specific locations. When doing so override the following methods, as required:</p> Method Reason to extend initializeLog() Action to be performed before writing each log. This is only triggered if there are any logs to be written. convertLogEntryToMessage() Use this if you do not intend to use a formatter. It should return a string to be written out. outputLogEntryMessage() This is where you put your custom logic to write to the relevant location. terminateLog() Action to be performed after writing all logs, such as closing a file or database connection."},{"location":"topicguides/approach.html#filter-logs","title":"Filter logs","text":"<p>The LogWriter's <code>writeToLog()</code> function retrieves LogEntries based on the log level, using inclusive minimum and maximum levels. This can be used to get entries matching a specific log level, by using the same level for both minimum and maximum. Alternatively it can used to get all logs at or above a certain level, e.g. LOG_INFO or higher. Because LOG_FATAL corresponds to the integer 1, LOG_INFO or higher actually corresponds to LogEntries with a level of 8 or lower.</p> <p>If you wish more sophisticated filtering, you can achieve this with extended classes or pattern matching.</p>"},{"location":"tutorials/index.html","title":"Tutorials","text":"<p>Tutorials give hands-on introduction on how to use VoltScript Logging.</p> <ul> <li>Create a Stream LogWriter to write logs to a text file</li> </ul>"},{"location":"tutorials/streamLogWriter.html","title":"Create a Stream LogWriter to Write Logs to a Text File","text":""},{"location":"tutorials/streamLogWriter.html#prerequisites","title":"Prerequisites","text":"<p>It's beneficial if you're familiar with how VoltScript Logging works and understand the basics of the BasicLogWriter class. Please review the following How-Tos for more information:</p> <ul> <li>Integrate logging in code</li> <li>Use LogWriters</li> <li>Extend BaseLogWriter</li> </ul>"},{"location":"tutorials/streamLogWriter.html#introduction","title":"Introduction","text":"<p>This tutorial will help you understand the basics of extending the BaseLogWriter class by creating a LogWriter that uses <code>StreamVSE</code> extension to write your logs to a text file. It also takes advantage of the <code>OSUtilsVSE</code> extension to ensure the <code>logs</code> directory is created.</p> <p>Before writing your code, you'll need to add these VSEs to your code by using dependency management - see Use dependency management for more information.</p>"},{"location":"tutorials/streamLogWriter.html#create-the-streamlogwriter-class","title":"Create the StreamLogWriter Class","text":"<p>We'll begin by extending the BaseLogWriter class to add in support for writing our log entries to a file.</p> <p>Now there are a few methods within the BaseLogWriter class that we will need to overwrite:</p> <ul> <li>Sub New - this is where we'll create our initial log directory path</li> <li>Sub InitializeLog - this is where we'll instantiate our Stream object with the appropriate path and file name</li> <li>Sub outputLogEntryMessage - this is where we'll add each log entry to our file stream each time one is added to the log</li> <li>Sub terminateLog - this is where we close the file stream, which commits all writes and closes the file on the disk</li> </ul> <p>Let's start by setting up the basics of our <code>StreamLogWriter</code> class.</p>"},{"location":"tutorials/streamLogWriter.html#streamlogwriter-the-basics","title":"StreamLogWriter - The Basics","text":"<p>Let's create the outline of our <code>StreamLogWriter</code> class and add in some necessary class properties that we'll need.</p> <pre><code>Class LogWriterStream as BaseLogWriter\n    Private logDir_ as String\n    Private logFilePath_ as String\n    Private logStream_ as Stream\n\nEnd Class\n</code></pre> <ul> <li><code>logDir_</code> - the full directory path to our <code>logs</code> directory</li> <li><code>logFilePath_</code> - the full file path to the current log file being written</li> <li><code>logStream</code> - the <code>Stream</code> object used to write our log file</li> </ul> <p>Next we'll add in the various subroutines mentioned earlier. Note that the signatures for each method are the same as the corresponding subroutines found in the BaseLogWriter class.</p>"},{"location":"tutorials/streamLogWriter.html#sub-new","title":"Sub New()","text":"<p>The <code>Sub New()</code> method is where we create the directory path for our <code>logs</code> directory using the <code>CurDir()</code> function that's a part of VoltScript.</p> <pre><code>Sub New(label as String, minLevel as Integer, maxLevel as Integer, formatter as String)\n    ' this will write the log entries to a subdirectory called logs in the current directory\n    logDir_ = CurDir() &amp; \"/logs\"\nEnd Sub\n</code></pre>"},{"location":"tutorials/streamLogWriter.html#sub-initializelog","title":"Sub InitializeLog()","text":"<p>The <code>Sub InitializeLog()</code> method is where we create the full path for our log file and use it to instantiate our <code>Stream</code> object.</p> <pre><code>Sub initializeLog()\n    Dim rbool as Boolean\n    Dim myOS as New OSUtils\n\n    ' make sure the logStream object is loaded, \n    ' and the file path is set appropriately\n    If logStream_ is nothing Then\n        Set logStream_ = New Stream\n\n        rbool = myOS.makeDirectories(logDir_) ' ensures the log directory exists \n        If not rbool Then Error 1001, \"Error creating log directory (\" &amp;_ \n        logDir_ &amp; \")\"\n\n        logFilePath_ = logDir_ &amp; \"/\" &amp;_ \n        \"log_\" &amp; Format(Now, \"YYYYMMDD-hhmmss\") &amp;_ \n        \"_\" &amp; createUUID() &amp; \".log\"\n\n        Call logStream_.open(logFilePath_, \"UTF-8\")\n    End If\nEnd Sub\n</code></pre>"},{"location":"tutorials/streamLogWriter.html#sub-outputlogentrymessage","title":"Sub outputLogEntryMessage()","text":"<p>The <code>Sub outputLogEntryMessage()</code> is used to add each log entry to the log stream.</p> <pre><code>Public Sub outputLogEntryMessage(message as String)\n    ' this writes the log entry to the stream \n    ' every time a log entry is added to the log\n    Call logStream_.writeText(message, EOL_LF)\nEnd Sub\n</code></pre>"},{"location":"tutorials/streamLogWriter.html#sub-terminatelog","title":"Sub terminateLog()","text":"<p>The <code>Sub terminateLog()</code> method is used to close the log file stream and ensure its properly written to disk.</p> <pre><code>Public Sub terminateLog()\n    ' this closes the stream and writes the logs to the file on disk\n    Call logStream_.close()\nEnd Sub\n</code></pre> <p>When it's all put together, it looks like this...</p> <pre><code>Class LogWriterStream as BaseLogWriter\n    Private logDir_ as String\n    Private logFilePath_ as String\n    Private logStream_ as Stream\n\n    Sub New(label as String, minLevel as Integer, maxLevel as Integer, formatter as String)\n    ' this will write the log entries to a subdirectory called logs in the current directory\n        logDir_ = CurDir() &amp; \"/logs\"\n    End Sub\n\n    Sub initializeLog()\n        Dim rbool as Boolean\n        Dim myOS as New OSUtils\n\n        ' make sure the logStream object is loaded, and the file path is set appropriately\n        If logStream_ is nothing Then\n            Set logStream_ = New Stream\n            rbool = myOS.makeDirectories(logDir_) ' ensures the log directory exists \n            If not rbool Then Error 1001, \"Error creating log directory (\" &amp; logDir_ &amp; \")\"\n            logFilePath_ = logDir_ &amp; \"/\" &amp; \"log_\" &amp; Format(Now, \"YYYYMMDD-hhmmss\") &amp; \"_\" &amp; createUUID() &amp; \".log\"\n            Call logStream_.open(logFilePath_, \"UTF-8\")\n        End If\n    End Sub\n\n    Public Sub outputLogEntryMessage(message as String)\n        ' this writes the log entry to the stream every time a log entry is added to the log\n        Call logStream_.writeText(message, EOL_LF)\n    End Sub\n\n    Public Sub terminateLog()\n        ' this closes the stream and writes the logs to the file on disk\n        Call logStream_.close()\n    End Sub\n\nEnd Class\n</code></pre> <p>Now that we have our StreamLogWriter class, let's write a small script to test and make sure it works.</p>"},{"location":"tutorials/streamLogWriter.html#testing-the-streamlogwriter-class","title":"Testing the StreamLogWriter Class","text":"<p>We can test our StreamLogWriter class by adding a small <code>Sub Initialize</code> routine to our script library. In this subroutine we'll:</p> <ul> <li>Instantiate our <code>StreamLogWriter</code> object by calling the <code>New</code> method</li> <li>Add our new <code>streamWriter</code> object to the <code>globalLogSession</code></li> <li>Add a few log entries to the <code>globalLogSession</code> object</li> </ul> <pre><code>Sub Initialize\n    Dim streamWriter as New LogWriterStream(\"StreamLogWriter\", LOG_DEBUG, LOG_ERROR, \"{{LEVELNAME}}: {{MESSAGE}}\")\n\n    Call globalLogSession.addLogWriter(streamWriter)\n    Call globalLogSession.createLogEntry(LOG_INFO, \"Here's a log entry\", \"\", \"\")\n    Call globalLogSession.createLogEntry(LOG_ERROR, \"Error encountered\", \"Here's a logged error\", \"\")\n    Call globalLogSession.createLogEntry(LOG_DEBUG, \"Debug message\", \"Here's a debug message\", \"\")\nEnd Sub\n</code></pre>"},{"location":"tutorials/streamLogWriter.html#results","title":"Results","text":"<p>If your code runs successfully you'll find a new <code>logs</code> subdirectory under your current directory, and it will contain your log file. The contents of the log file should look like this:</p> <pre><code>INFO: Here's a log entry\nERROR: Error encountered\nDEBUG: Debug message\n</code></pre>"}]}